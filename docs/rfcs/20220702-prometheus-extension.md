Prometheus extension for CeresDB 
---------------------------

- Feature Name: prometheus-extension
- Start Date: 2022-07-03
- Tracking Issue: TBD

# Summary
Drop-in and full-featured Prometheus extension for CeresDB

# Motivation
Prometheus and PromQL are wide used in monitoring scenarios. It would be great if CeresDB is compatible with it. 

CeresDB has the ability to store and compute a large amount of data. But PromQL contains some specific operators. Though CeresDB supports a subset, it is hard and infeasible to implement all of them.

There are some brilliant distributed solutions like `Thanos` and `Cortex`. But the computation ability is limited in aspects of distributed execution or extensible (`Thanos` supports split query on time range (https://thanos.io/tip/components/query-frontend.md/#splitting). Combining `Prometheus`with `CeresDB` can gain both high performance computation and the ability to query in other forms like SQL.  

This proposal aims to provides a way that:

- Easy to integrate with vanilla Prometheus server.
- Able to offload computation to CeresDB 

# Details
The proposed architecture contains three parts `Prometheus`, `CeresDB`, and `Query Frontend`. They are deployed together in a single node. This node provides Prometheus service via `Query Frontend` and other two components are internal.

```plaintext
                Prometheus
                Protocol
                    ▲
                    │
 ┌──────────────────┼──────────────────┐
 │                  │                  │
 │        ┌─────────┴──────────┐       │
 │        │   Query Frontend   │       │
 │        └─┬─▲──────────────┬─┘       │
 │          │ │              │         │
 │     sub- │ │query         │CeresDB  │
 │    PromQL│ │result        │  AST    │
 │    (HTTP)│ │              │ (gRPC)  │ ┌──────────┐
 │ ┌────────▼─┴─┐        ┌───▼─────┐   │ │ CeresDB  │
 │ │ Prometheus ◄────────► CeresDB ├───┼─┤ Storage  │
 │ └────────────┘ Remote └─────────┘   │ │(WAL/OSS) │
 │                Storage              │ └──────────┘
 │Compute         Interface            │
 │Node            (Read)               │
 └─────────────────────────────────────┘
```

## Query Frontend
The entry point of one deploy node. It masquerades as a `Prometheus` server (this proposal only focus on read). This is added to act as a proxy layer on top of `Prometheus` and `CeresDB` services.

A query frontend will analyze incoming `PromQL` query, and split it into two sub-parts, then feed them to the underlying `Prometheus` and `CeresDB`. The two parts should be legal to both receivers, i.e both `Prometheus`and `CeresDB` can process it like a normal request.

Frontend should be able to parse and manipulate both PromQL and CeresDB's AST. It assembles CeresDB's AST based on the information about operators supported by CeresDB (like sum, max, min, etc.). And replace these operators by a selector, which will be computed in CeresDB later. Example:

--------------------

Input PromQL:
```
histogram_quantile(0.9, sum by (le) (rate(http_request_duration_seconds_bucket[10m])))
```
This PromQL queries p90 of metric `http_request_duration_sections_bucket`. CeresDB supports `sum`and `rate` and we can push them down to CeresDB's part. `histogram_quantile`is not supported thus it remains in PromQL and is calculated by Prometheus. So the two parts derived from this example are:
```promql
histogram_quantile(0.9, sum_rate_http_result)
```
and
```sql
SELECT
    -- rate is an UDF in CeresDB
    sum(rate('10m', field)) AS sum_rate_http_result
FROM http_request_duration_seconds_bucket
WHERE timestamp BETWEEN A AND B
GROUP BY le
ORDER BY timestamp

```
------------------------------

Frontend also needs to forward query result from Prometheus.

## Communication
In this proposal, `CeresDB` is integrated into `Prometheus` as a remote (read) storage within one node. `Prometheus`' remote request protocol is defined here: https://github.com/prometheus/prometheus/blob/main/prompb/remote.proto.

Query Frontend have to feed PromQL and SQL to servers separately because this interface cannot pass query plan (except filter). The two requests are associated by a `TaskID` generated by Frontend. This ID is present in remote request and `CeresDB` can recognize it. 

At this point we can describe a complete flow for serving a PromQL query:

1. `Query Frontend` accept a PromQL
2. `Query Frontend` split the original PromQL into two sub queries and assign a `TaskID`.
3. `Query Frontend` sends sub PromQL to Prometheus and sub SQL to CeresDB. 
4. `Prometheus` processes the sub PromQL. It will query the data source (CeresDB) for data.
5. `CeresDB` receives a request from `Prometheus`, and a sub-SQL with the same `TaskID` from `Query Frontend`.
6. `CeresDB` processes and returns result to `Prometheus`
7. `Prometheus` processes and returns result.
8. `Query Frontend` forwards results to the client.

# Drawbacks
- Sub query for CeresDB is sent separately with `Prometheus`' data read request. CeresDB needs to maintain this extra state.

# Alternatives
- Modify `Prometheus` rather than using the native upstream version. By doing this we can
   - Extend the remote storage API to pass SQL sub-query
   - Merge `Prometheus` and `Query Frontend` into one component.
- Do not bound these three components to gether for a more flexible deployment. But this may requires a more complex routing mechanism.
